<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 1: Transition Systems and Invariants</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../assets/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 1: Transition Systems and Invariants</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#what-is-model-checking">What is model checking?</a></li>
<li><a href="#transition-systems">Transition systems</a>
<ul>
<li><a href="#example-traffic-light">Example: Traffic light</a></li>
<li><a href="#running-a-transition-system">Running a transition system</a></li>
</ul></li>
<li><a href="#checking-invariants">Checking invariants</a>
<ul>
<li><a href="#predicates">Predicates</a></li>
<li><a href="#propositions">Propositions</a></li>
<li><a href="#depth-first-search">Depth-first search</a></li>
<li><a href="#the-checkinvariant-function">The <code>checkInvariant</code> function</a></li>
<li><a href="#checking-a-traffic-light-invariant">Checking a traffic light invariant</a></li>
</ul></li>
<li><a href="#whats-next">What’s next?</a></li>
</ul>
</nav>
<p>Recently, I’ve been reading a <a href="https://www.amazon.com/Principles-Model-Checking-MIT-Press/dp/026202649X/ref=sr_1_1?crid=2RGC1B0N79HIJ&amp;keywords=principles+of+model+checking&amp;qid=1651762001&amp;sprefix=principles+of+model+checking%2Caps%2C134&amp;sr=8-1">book</a> and watching a <a href="https://www.youtube.com/watch?v=Y5Hg4MvUXc4&amp;list=PLwabKnOFhE38C0o6z_bhlF_uOUlblDTjh">lecture series</a> about model checking. This is a topic I’ve learned a bit about in the past, but never really studied in earnest. I highly recommend these resources to anyone who is interested in learning more.</p>
<p>In model checking, we create a <em>model</em> of some sort of stateful artifact, like a computer program, sequential circuit, or even something in the “real world” (like a vending machine or traffic light). Then, we state a <em>property</em> we would like to hold about <em>all possible behaviors</em> of the model. Finally, we check whether this property holds for the model, using a variety of nifty algorithms.</p>
<p>This series of blog posts constitutes a straightforward introduction to model checking, using Haskell code to express the ideas and implement the algorithms. The intended audience is anyone who knows a bit of Haskell and a bit of logic, and who wants to understand how model checking works.</p>
<p>This post was generated with <code>pandoc</code> from a <a href="https://github.com/benjaminselfridge/model-checking/blob/master/src/ModelChecking1.lhs">literate haskell document</a>.</p>
<h1 id="what-is-model-checking">What is model checking?</h1>
<p>Modern physical and digital systems can be incredibly complex. They are often composed of multiple interacting subsystems, each with its own internal state. It can become extremely hard to reason about the correctness of these systems, because the details of exactly how and when the system changes state may be subtle.</p>
<p>There is only one way to get hard guarantees about a complex system: by using <em>mathematical rigor</em> to describe the system in question, to specify the desired property, and to prove or disprove that the system satisfies the property. This can be done entirely manually (i.e. constructing a proof or counterexample by hand), or with the help of some degree of tool automation. Typically, the more automation a technique offers, the more limited it is in other aspects (for instance, in the size of the models that can be verified). Hand proofs, automated theorem proving, abstract interpretation, SAT/SMT solving, BDDs, and model checking are all examples of formal methods techniques, and each of these techniques occupies its own special compromise point in the design space.</p>
<p>Model checking is at the “high automation/limited scalability” end of this spectrum. Model checking is extremely powerful because it is a push-button process. Once you specify your model and the property you want to check, the computer does the rest. However, the method is fundamentally limited by the “state-explosion” problem. Model checking involves an exhaustive search of the entire state space of a system, and if this space is too big, verification becomes infeasible. Model checking has had most of its success in the hardware domain, where state and control logic are much smaller and simpler than in a typical piece of software. It is a good method to use for <em>finding bugs</em> because it’s great at producing small counterexamples, if they exist.</p>
<p>In practice, model checking consists of three basic steps:</p>
<ol type="1">
<li><p>Capture the essence of the system you want to verify by constructing a <em>model</em> of this system, using a formal language that a model checking tool can understand.</p></li>
<li><p>Capture the property you want to verify about your model in a property specification language (usually this is the same language in which the model is described).</p></li>
<li><p>Press “go”, and wait for the tool to either a) declare that the property holds for your model, b) provide a counterexample, or c) give up.</p></li>
</ol>
<p>The basic idea of model checking is simple: represent all possible states of your system as nodes in a directed graph, and represent the possible changes from state to state as directed edges from one node to another. Then, checking a property of your system boils down to running some sort of search algorithm on the graph. This graph-based representation is called a <em>transition system</em>.</p>
<p>The goal of this first post is to introduce the notion of a transition system, and to show how we can verify a simple type of property called an <em>invariant</em>. The example used throughout this post (a traffic light with three states) is a pedagogical one, and it’s very trivial. The point in this first post is not to show you the full power of model checking all at once; it’s to set up a conceptual framework that we can build on in subsequent posts.</p>
<p>Each post will build on the previous one, and we will gradually move from simple systems and properties to more complex and meaningful ones. By the final post in this series, we will have developed a full-blown model checker in Haskell, and we will use it to verify some non-trivial properties about a cache coherence protocol.</p>
<h1 id="transition-systems">Transition systems</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking1</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (find)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (<span class="dt">RandomGen</span>, randomR)</span></code></pre></div>
<p>A <em>transition system</em> over state set <code>s</code>, action set <code>action</code>, and atomic propositional variables <code>ap</code> is defined as follows:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  {<span class="ot"> tsInitialStates ::</span> [s]</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsLabel         ::</span> s <span class="ot">-&gt;</span> [ap]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  ,<span class="ot"> tsTransitions   ::</span> s <span class="ot">-&gt;</span> [(action, s)]</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>The type <code>s</code> represents all possible states our system can be in; if the system is a traffic light, <code>s</code> might be the set of colors <code>{red, green, yellow}</code>; if it’s a sequential circuit, it might be the current value of a set of bits.</p>
<p>The type <code>ap</code> represents the relevant properties of a given state. Depending on what property we are interested in for our system, we might choose a corresponding set of variables <code>ap</code> that help us to capture the property using propositional logic. Each element of <code>ap</code> is a boolean-valued variable, and depending on which state the system is in, each such variable may be either true or false. The <code>tsLabel</code> function tells us the <em>true-set</em> of each state. The <em>true-set</em> is simply the set of variables which are true in a given state. If a variable is in this list, then it’s true; if it’s absent from the list, it’s false.</p>
<p>The type <code>action</code> is simply a “name” for each outgoing transition. These names do not carry any semantic content, but it’s often useful to give a name to a transition to indicate “what is happening” as the system changes from state to another.</p>
<p>In summary, here is the intuition behind each of the three fields of a transition system.</p>
<ul>
<li><code>tsInitialStates ts</code>: “the states that the system can start in”</li>
<li><code>tsLabel ts s</code>: “the set of variables which are true in state <code>s</code>”</li>
<li><code>tsTransitions ts s</code>: “all of <code>s</code>’s outgoing transitions”</li>
</ul>
<p>Let’s look at a trivial example of a transition system.</p>
<h2 id="example-traffic-light">Example: Traffic light</h2>
<figure>
<img src="../images/traffic_light.png" style="width:30.0%;height:30.0%" alt="Transition system for a traffic light" /><figcaption aria-hidden="true">Transition system for a traffic light</figcaption>
</figure>
<p>We can create a very simple transition system representing the states and transitions of a traffic light. The states <code>s</code> will be the colors red, yellow, and green:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Color</span> <span class="ot">=</span> <span class="dt">Red</span> <span class="op">|</span> <span class="dt">Yellow</span> <span class="op">|</span> <span class="dt">Green</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>The atomic propositional variables <code>ap</code> that we will use is also <code>Color</code>. The idea is that a color is <code>True</code> in a given state if and only if that color is currently lit up. In this example, states and atomic propositional variables are one and the same; however, this will not always be the case, and when we study more interesting examples, we will use a much richer set of atomic propositional variables.</p>
<p>There will only be one action:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Change</span> <span class="ot">=</span> <span class="dt">Change</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Our set of transitions will allow <code>Red</code> to transition to <code>Green</code>, <code>Green</code> to <code>Yellow</code>, and <code>Yellow</code> to <code>Red</code>. Below is the definition of the traffic light’s transition system:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traffic_light ::</span> <span class="dt">TransitionSystem</span> <span class="dt">Color</span> <span class="dt">Change</span> <span class="dt">Color</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [<span class="dt">Red</span>]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [s]</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Red</span>    <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Green</span> )]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Green</span>  <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Yellow</span>)]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Yellow</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Red</span>   )]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>Notice that in each state <code>s</code>, where <code>s</code> is one of the colors <code>Red</code>, <code>Yellow</code>, or <code>Green</code>, the label of <code>s</code> is simply <code>[s]</code>, because the only color that is lit up in state <code>s</code> is <code>s</code> itself.</p>
<h2 id="running-a-transition-system">Running a transition system</h2>
<p>A <em>run</em> of a transition system is a finite or infinite path in the underlying graph:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Path</span> s action <span class="ot">=</span> <span class="dt">Path</span> {<span class="ot"> pathHead ::</span> s,<span class="ot"> pathTail ::</span> [(action, s)] }</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
<p>The following path-constructing functions will be useful:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">singletonPath ::</span> s <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>singletonPath s <span class="ot">=</span> <span class="dt">Path</span> s []</span></code></pre></div>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">consPath ::</span> (s, action) <span class="ot">-&gt;</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>consPath (s, action) (<span class="dt">Path</span> s&#39; tl) <span class="ot">=</span> <span class="dt">Path</span> s ((action, s&#39;)<span class="op">:</span>tl)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">reversePath ::</span> <span class="dt">Path</span> s action <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>reversePath (<span class="dt">Path</span> s prefix) <span class="ot">=</span> go [] s prefix</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> go suffix s [] <span class="ot">=</span> <span class="dt">Path</span> s suffix</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        go suffix s ((action, s&#39;)<span class="op">:</span>prefix) <span class="ot">=</span> go ((action, s)<span class="op">:</span>suffix) s&#39; prefix</span></code></pre></div>
<p>In the transitions systems we’ll define, it will be useful to be able to examine random infinite runs of the system to get a feel for what the possibilites are:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">randomRun ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">-&gt;</span> <span class="dt">Path</span> s action</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>randomRun g ts <span class="ot">=</span> <span class="kw">let</span> (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> (tsInitialStates ts) <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>                     s <span class="ot">=</span> tsInitialStates ts <span class="op">!!</span> i</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> <span class="dt">Path</span> s (loop g&#39; s ts)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> loop g s ts <span class="ot">=</span> <span class="kw">let</span> nexts <span class="ot">=</span> tsTransitions ts s</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>                          (i, g&#39;) <span class="ot">=</span> randomR (<span class="dv">0</span>, <span class="fu">length</span> nexts <span class="op">-</span> <span class="dv">1</span>) g</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                          (action, s&#39;) <span class="ot">=</span> nexts <span class="op">!!</span> i</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">in</span> (action, s&#39;) <span class="op">:</span> loop g&#39; s&#39; ts</span></code></pre></div>
<p>Let’s generate a random run of our <code>traffic_light</code> example in <code>ghci</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> g <span class="ot">=</span> mkStdGen <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> r <span class="ot">=</span> randomRun g traffic_light</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> pathHead r</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Red</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="fu">take</span> <span class="dv">6</span> (pathTail r)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  [(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>),(<span class="dt">Change</span>,<span class="dt">Red</span>),(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>),(<span class="dt">Change</span>,<span class="dt">Red</span>)]</span></code></pre></div>
<p>Because each state in <code>traffic_light</code> has exactly one outgoing transition, this is the only run we will ever get. In subsequent posts, we’ll look at nondeterministic transition systems which will return different runs with different random generators.</p>
<h1 id="checking-invariants">Checking invariants</h1>
<p>Given a state <code>s</code> of a transition system <code>ts</code>, we can ask which atomic propositional variables hold in <code>s</code>; that is, given a particular variable <code>p :: ap</code>, we can determine whether <code>p</code> is true in <code>s</code> via</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>p <span class="ot">`elem`</span> tsLabel ts s</span></code></pre></div>
<p>If the result of this call is <code>True</code>, then <code>p</code> is <code>True</code> in state <code>s</code>; if it is <code>False</code>, then <code>p</code> is <code>False</code> in state <code>s</code>.</p>
<p>We can generalize this from atomic propositional variables to all <em>propositions</em>, which are logical formulas stated “in terms of” the variables <code>ap</code>, using boolean connectives (and, or, implies, not) to build larger formulas out of smaller ones. In this section, will define a <code>Proposition</code> in Haskell to be any function that maps true-sets to <code>Bool</code>s. Since the label of every state in a transition system is its true-set, we can therefore ask, for each individual state, whether a given proposition is true when evaluated at the label of that state – that is, whether the state <em>satisfies</em> the proposition.</p>
<p>We can take this one step further and ask whether a proposition is satisfied by <em>every</em> reachable state of a transition system. If this is true for a given proposition, that proposition is said to be an <em>invariant</em> of the system. In order to determine whether a given proposition is an invariant, we simply search the transition system’s underlying graph, evaluating the proposition at every state label we reach; if any of the labels do not satisfy the proposition, then it is not an invariant.</p>
<p>This section will introduce the definition of a <code>Proposition</code>, and will define a simple depth-first search function over a transition system that checks whether a given proposition holds for all reachable states of the system. We will then apply this function to our traffic light system to check that a very simple invariant holds.</p>
<h2 id="predicates">Predicates</h2>
<p>In this section, we’ll introduce the general notion of a <em>predicate</em>, which we will use in this post and in every subsequent post. We will see that a <em>proposition</em> is a special type of predicate.</p>
<p>A <em>predicate</em> is any single-argument function that returns a <code>Bool</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Predicate</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Predicates are a fundamental building block for many of the most commonly used functions in Haskell:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">even</span><span class="ot">   ::</span> <span class="dt">Integral</span> a <span class="ot">=&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="fu">null</span><span class="ot">   ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> <span class="dt">Predicate</span> (t a)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">and</span><span class="ot">    ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> <span class="dt">Predicate</span> (t <span class="dt">Bool</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="fu">all</span><span class="ot">    ::</span> <span class="dt">Foldable</span> t <span class="ot">=&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (t a)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">filter</span><span class="ot"> ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span></code></pre></div>
<p>A very simple example of a predicate is <code>true</code>, which holds for all inputs:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">true ::</span> <span class="dt">Predicate</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>true _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>Similarly, <code>false</code> holds for no inputs:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">false ::</span> <span class="dt">Predicate</span> a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>false _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>We can “lift” all of the usual boolean operators to work with predicates:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&amp;) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.&amp;</span> q) a <span class="ot">=</span> p a <span class="op">&amp;&amp;</span> q a</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span> <span class="op">.&amp;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="ot">(.|) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.|</span> q) a <span class="ot">=</span> p a <span class="op">||</span> q a</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">2</span> <span class="op">.|</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="ot">pnot ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>pnot p a <span class="ot">=</span> <span class="fu">not</span> (p a)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="ot">(.-&gt;) ::</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>(p <span class="op">.-&gt;</span> q) a <span class="ot">=</span> <span class="kw">if</span> p a <span class="kw">then</span> q a <span class="kw">else</span> <span class="dt">True</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">.-&gt;</span></span></code></pre></div>
<p>These operators (called <em>boolean connectives</em>) are useful for building larger predicates out of smaller ones:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> divisible_by_3 a <span class="ot">=</span> a <span class="ot">`mod`</span> <span class="dv">3</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> divisible_by_6 <span class="ot">=</span> <span class="fu">even</span> <span class="op">.&amp;</span> divisible_by_3</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="fu">map</span> divisible_by_6 [<span class="dv">0</span><span class="op">..</span><span class="dv">12</span>]</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">True</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">False</span>,<span class="dt">True</span>]</span></code></pre></div>
<p>When working with predicates, the following “flipped application” operator is useful:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(|=) ::</span> a <span class="ot">-&gt;</span> <span class="dt">Predicate</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">|=</span> p <span class="ot">=</span> p a</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">0</span> <span class="op">|=</span></span></code></pre></div>
<p>Given some object <code>a</code>, and some predicate <code>p :: Predicate a</code>, we read the statement <code>a |= p</code> as “<code>a</code> satisfies <code>p</code>”.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="dv">5</span> <span class="op">|=</span> divisible_by_6     <span class="co">-- Does 5 satisfy divisible_by_6?</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">24</span>] <span class="op">|=</span> <span class="fu">all</span> <span class="fu">even</span> <span class="co">-- Does [2, 10, 24] satisfy all even?</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span></code></pre></div>
<p>This flipped application syntax may seem weird, but reading <code>|=</code> as “satisfies” should help.</p>
<h2 id="propositions">Propositions</h2>
<p>We define a <em>proposition</em> over the atomic propositions <code>ap</code> to be a predicate over <code>[ap]</code>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Proposition</span> ap <span class="ot">=</span> <span class="dt">Predicate</span> [ap]</span></code></pre></div>
<p>In this context, a list <code>aps :: [ap]</code> is thought of as “the set of all atomic propositions which are true.” Given a single atomic proposition <code>p</code>, we can form the proposition “<code>p</code> holds” as follows:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atom ::</span> <span class="dt">Eq</span> ap <span class="ot">=&gt;</span> ap <span class="ot">-&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>atom p aps <span class="ot">=</span> p <span class="ot">`elem`</span> aps</span></code></pre></div>
<p>Using the <code>atom</code> function, along with our boolean connectives <code>.&amp;</code>, <code>.|</code>, <code>.-&gt;</code>, and <code>pnot</code>, we can “build up” propositional formulas from atomic propositions, and we can then ask whether the resulting formula is satisfied by a particular true-set. Let’s mess around a bit in ghci to get a feel for how this works:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="kw">data</span> <span class="dt">AB</span> <span class="ot">=</span> <span class="dt">A</span> <span class="op">|</span> <span class="dt">B</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">B</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> pnot (atom <span class="dt">B</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span> <span class="op">.&amp;</span> atom <span class="dt">B</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span> <span class="op">.|</span> atom <span class="dt">B</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">A</span> <span class="op">.-&gt;</span> atom <span class="dt">B</span></span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> [<span class="dt">A</span>] <span class="op">|=</span> atom <span class="dt">B</span> <span class="op">.-&gt;</span> atom <span class="dt">A</span></span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span></code></pre></div>
<p>Recall that our states are labeled by <em>true-sets</em>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tsLabel ::</span> <span class="dt">TransitionSystem</span> s action ap <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [ap]</span></code></pre></div>
<p>Therefore, given a proposition <code>f :: Proposition ap</code>, which is just a function <code>f :: [ap] -&gt; Bool</code>, we can ask whether a particular state <code>s</code> of our transition system satisfies <code>f</code> like so:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>tsLabel ts s <span class="op">|=</span> f</span></code></pre></div>
<p>Let’s try this out a bit with our traffic light system:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span> <span class="co">-- which colors are &quot;true&quot; in state Red?</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>  [<span class="dt">Red</span>]</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span> <span class="op">|=</span> atom <span class="dt">Red</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span> <span class="op">|=</span> (atom <span class="dt">Red</span> <span class="op">.|</span> atom <span class="dt">Green</span>)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span> <span class="op">|=</span> atom <span class="dt">Red</span> <span class="op">.-&gt;</span> atom <span class="dt">Yellow</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>  <span class="dt">False</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> tsLabel traffic_light <span class="dt">Red</span> <span class="op">|=</span> atom <span class="dt">Yellow</span> <span class="op">.-&gt;</span> atom <span class="dt">Green</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  <span class="dt">True</span></span></code></pre></div>
<h2 id="depth-first-search">Depth-first search</h2>
<p>Given a transition system <code>ts</code> and a proposition <code>f</code> over <code>ts</code>’s atomic propositional variables, we can ask: “Does <code>f</code> hold at all reachable states in <code>ts</code>?” A proposition which is supposed to hold at all reachable states of a transition system is called an <em>invariant</em>.</p>
<p>To check whether an invariant holds, we evaluate the proposition on each reachable state (more precisely, on the <em>label</em> of each reachable state). To do this, we first define a lazy depth-first search to collect all the states.</p>
<p>Our depth-first search algorithm produces each reachable state, along with the path traversed to reach that state. The path will be useful for giving informative counterexamples.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">dfs ::</span> <span class="dt">Eq</span> s <span class="ot">=&gt;</span> [s] <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> [(action, s)]) <span class="ot">-&gt;</span> [(s, <span class="dt">Path</span> s action)]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>dfs starts transitions <span class="ot">=</span> (\p<span class="op">@</span>(<span class="dt">Path</span> s tl) <span class="ot">-&gt;</span> (s, reversePath p)) <span class="op">&lt;$&gt;</span> loop [] (singletonPath <span class="op">&lt;$&gt;</span> starts)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> loop visited stack <span class="ot">=</span> <span class="kw">case</span> stack <span class="kw">of</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>          [] <span class="ot">-&gt;</span> []</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>          ((<span class="dt">Path</span> s _)<span class="op">:</span>stack&#39;) <span class="op">|</span> s <span class="ot">`elem`</span> visited <span class="ot">-&gt;</span> loop visited stack&#39;</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>          (p<span class="op">@</span>(<span class="dt">Path</span> s _)<span class="op">:</span>stack&#39;) <span class="ot">-&gt;</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> nexts <span class="ot">=</span> [ consPath (s&#39;, action) p <span class="op">|</span> (action, s&#39;) <span class="ot">&lt;-</span> transitions s ]</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a>            <span class="kw">in</span> p <span class="op">:</span> loop (s<span class="op">:</span>visited) (nexts <span class="op">++</span> stack&#39;)</span></code></pre></div>
<h2 id="the-checkinvariant-function">The <code>checkInvariant</code> function</h2>
<p>Now, to check whether a proposition <code>f :: Proposition ap</code> is an invariant of a transition system, we simply collect all the system’s reachable states via <code>dfs</code> and make sure the invariant holds for each of their labels, producing a path to a bad state if there is one:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">checkInvariant ::</span> <span class="dt">Eq</span> s</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>               <span class="ot">=&gt;</span> <span class="dt">Proposition</span> ap</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> s action ap</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (s, <span class="dt">Path</span> s action)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>checkInvariant f ts <span class="ot">=</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> rs <span class="ot">=</span> dfs (tsInitialStates ts) (tsTransitions ts)</span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">in</span> find (\(s,_) <span class="ot">-&gt;</span> tsLabel ts s <span class="op">|=</span> pnot f) rs</span></code></pre></div>
<h2 id="checking-a-traffic-light-invariant">Checking a traffic light invariant</h2>
<p>Let’s check an invariant of our traffic light system – that the light is never red and green at the same time. It’s not a very interesting invariant, but it’s a good one for any traffic light to have.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Red</span> <span class="op">.&amp;</span> atom <span class="dt">Green</span>)) traffic_light</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<p>The result <code>Nothing</code> means there were no counterexamples, which means our invariant holds! Let’s try it with an invariant that doesn’t hold:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) traffic_light</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (<span class="dt">Yellow</span>,<span class="dt">Path</span> {pathHead <span class="ot">=</span> <span class="dt">Red</span>, pathTail <span class="ot">=</span> [(<span class="dt">Change</span>,<span class="dt">Green</span>),(<span class="dt">Change</span>,<span class="dt">Yellow</span>)]})</span></code></pre></div>
<p>Our invariant checking algorithm was able to find a path to a state that violated <code>pnot (atom Yellow)</code>; unsurprisingly, the bad state was <code>Yellow</code>. Because <code>Yellow</code> is reachable in our transition system, this property doesn’t hold. What if, however, <code>Yellow</code> is not reachable – for instance, in a simpler traffic light that goes directly from <code>Green</code> to <code>Red</code>?</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simple_traffic_light ::</span> <span class="dt">TransitionSystem</span> <span class="dt">Color</span> <span class="dt">Change</span> <span class="dt">Color</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>simple_traffic_light <span class="ot">=</span> <span class="dt">TransitionSystem</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [<span class="dt">Red</span>]</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [s]</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">case</span> s <span class="kw">of</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Red</span>   <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Green</span>)]</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Green</span> <span class="ot">-&gt;</span> [(<span class="dt">Change</span>, <span class="dt">Red</span>  )]</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>  }</span></code></pre></div>
<p>If we check <code>pnot (atom Yellow)</code>, we will find that the property holds, because <code>Yellow</code> isn’t reachable:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom <span class="dt">Yellow</span>)) simple_traffic_light</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<h1 id="whats-next">What’s next?</h1>
<p>This post describes the basic idea of model checking: represent the system you’d like to verify as a directed graph, and search the graph to make sure the desired property holds. The system we studied was simple enough to be pedagogically useful, but might be too trivial to illustrate the power of the technique. Furthermore, the property we verified was also extremely simple.</p>
<p>In the next post, we’ll discuss a technique for converting imperative computer programs into transition systems, and we will use this technique to verify a non-trivial invariant about a non-trivial program. In the post after that, we’ll discuss how to state and verify more interesting properties, like “every red light is immediately preceded by a yellow light.”</p>
</body>
</html>
