<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Model Checking in Haskell, Part 2: From Programs to Transition Systems</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../assets/pandoc.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Model Checking in Haskell, Part 2: From Programs to Transition Systems</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a-simple-imperative-programming-language">A simple imperative programming language</a>
<ul>
<li><a href="#the-modify-statement">The <code>Modify</code> statement</a></li>
<li><a href="#the-ifgoto-statement">The <code>IfGoto</code> statement</a></li>
<li><a href="#implementing-factorial">Implementing factorial</a></li>
</ul></li>
<li><a href="#parallel-programs">Parallel programs</a>
<ul>
<li><a href="#example-petersons-mutual-exclusion-algorithm">Example: Peterson’s mutual exclusion algorithm</a></li>
<li><a href="#from-parallel-programs-to-transition-systems">From parallel programs to transition systems</a></li>
<li><a href="#checking-petersons-algorithm">Checking Peterson’s algorithm</a></li>
</ul></li>
<li><a href="#whats-next">What’s next?</a></li>
</ul>
</nav>
<p>In the <a href="2022-05-10-model-checking-1.html">previous post</a>, we introduced transition systems, which are directed graphs that capture properties of the state of a system as it evolves through time. Each state in the graph was labeled with a <em>true-set</em>, the set of all atomic propositions which are true in that state. We explored how to build logical propositions in terms of the atomic propositions of the state labels, and how to check that such a proposition is an <em>invariant</em> of the transition system. By using an off-the-shelf graph search algorithm, we discovered all reachable states and evaluated the proposition at each state.</p>
<p>In this post, we will take a look at how transition systems can be derived from computer programs. We will develop a very simple imperative programming language, and then we will write a function that converts parallel programs written in this language to transition systems. Finally, we’ll use this language to implement Peterson’s algorithm for mutual exclusion, and we’ll use the <code>checkInvariant</code> function from the previous post to ensure that it is correct.</p>
<h1 id="a-simple-imperative-programming-language">A simple imperative programming language</h1>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ModelChecking2</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ModelChecking1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span> (liftA2)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Map.Strict</span> (<span class="dt">Map</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map.Strict</span> <span class="kw">as</span> <span class="dt">Map</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Vector</span> (<span class="dt">Vector</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Vector</span> <span class="kw">as</span> <span class="dt">Vec</span></span></code></pre></div>
<p>In this section, we’ll define a simple, Turing-complete imperative language with variable assignments and conditional gotos. The language will be implemented as an <em>embedded domain-specific language (eDSL)</em> in Haskell. The embedding will be (mostly) shallow. We will use Haskell functions to represent effects and state predicates. However, we will not allow these functions to modify or query the current line number in the program; that bit will be deeply embedded in the language AST.</p>
<p>Our language will be called <code>MIG</code>, which stands for <code>Modify</code>/<code>IfGoto</code>. In <code>MIG</code>, a program is a sequence of statements. There are two kinds of statements:</p>
<ol type="1">
<li><code>Modify</code>: modify the global variable environment (e.g. assign a variable to a value)</li>
<li><code>IfGoto</code>: test a condition; if it’s true, go to the given line number</li>
</ol>
<p>The <em>global variable environment</em>, or just the <em>environment</em>, is an assignment of <code>val</code>ues to a set of <code>var</code>iables. The environment is going to be a <code>Map</code> from <code>var</code>s to <code>val</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Env</span> var val <span class="ot">=</span> <span class="dt">Map</span> var val</span></code></pre></div>
<p>A statement that modifies the global variable environment is represented as an <em>effect</em>, which is a function taking the old environment to a new one:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Effect</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> <span class="dt">Env</span> var val</span></code></pre></div>
<p>We’ll use <code>Int</code> as a sensible type for our line numbers:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">LineNumber</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>A statement in <code>MIG</code> either modifies the current environment, or conditionally goes to the given line number:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Stmt</span> var val <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">Effect</span> var val)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">IfGoto</span> (<span class="dt">Predicate</span> (<span class="dt">Env</span> var val)) <span class="dt">LineNumber</span></span></code></pre></div>
<p>To execute a <code>Modify</code> statement, we simply apply the <code>Effect</code> to the current environment, thus modifying it, and then go to the next line in the program. To execute an <code>IfGoto</code> statement, we first test the <code>Predicate</code> against the current environment: if the predicate evaluates to true, then we go to the <code>LineNumber</code> indicated; if it is not true, then we go to the next line in the program.</p>
<p>We’ll also need an unconditional <code>goto</code> statement. We’ll define it as <code>IfGoto true</code>, where <code>true :: Predicate a</code> (defined in the previous post) is the function that always returns <code>True</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ot">goto ::</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>goto lineNum <span class="ot">=</span> <span class="dt">IfGoto</span> true lineNum</span></code></pre></div>
<p>Another occasionally useful statement is <code>noop</code>, which is implemented as a <code>Modify</code> that doesn’t actually do anything:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ot">noop ::</span> <span class="dt">Stmt</span> var val</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>noop <span class="ot">=</span> <span class="dt">Modify</span> <span class="fu">id</span></span></code></pre></div>
<p>A <code>MIG</code> program is just a <code>Vector</code> of statements:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Prog</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Stmt</span> var val)</span></code></pre></div>
<h2 id="the-modify-statement">The <code>Modify</code> statement</h2>
<p>In this section and the next section, we will define some helper functions that will make it easier to create readable statements in <code>MIG</code>. This will be a bit of a diversion from the main theme of model checking, but it is always worthwhile to get the details to look good and feel good. In this section, we focus on <code>Modify</code>; in the next, we’ll look at <code>IfGoto</code>.</p>
<p>The <code>Modify</code> constructor takes a single argument, an <code>Effect</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">Modify</span><span class="ot"> ::</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span></code></pre></div>
<p>Recall that an <em>effect</em> is a function that modifies the global variable environment:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Effect</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> <span class="dt">Env</span> var val</span></code></pre></div>
<p>In C, we might see a line like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> x = y * <span class="dv">4</span>;</span></code></pre></div>
<p>The left-hand side of the <code>=</code> is a variable, and the right-hand side is an <em>expression</em> that can be evaluated, given an environment that has a definition for the variable <code>y</code>. In <code>MIG</code>, we could write the corresponding <code>Modify</code> statement like so:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">XY</span> <span class="ot">=</span> <span class="dt">X</span> <span class="op">|</span> <span class="dt">Y</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (\env <span class="ot">-&gt;</span> Map.insert <span class="dt">X</span> (env <span class="op">Map.!</span> <span class="dt">Y</span> <span class="op">*</span> <span class="dv">4</span>) env)</span></code></pre></div>
<p>The function we passed to <code>Modify</code> took the current environment and modified it by looking up the value of <code>Y</code>, adding <code>4</code> to it, and setting <code>X</code> equal to the result. This is okay, but it would be much nicer to write something that looked more like the corresponding C statement.</p>
<p>To accomplish this, we’ll define an <em>assignment</em> operator that works on single variables. The operator will be <code>.=</code>, and the syntax</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">.=</span> e</span></code></pre></div>
<p>will mean “evaluate the expression <code>e</code> and assign the result to the variable <code>x</code>”. A simple way to represent an <em>expression</em> is as a function from the environment to a particular value:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Expr</span> var val <span class="ot">=</span> <span class="dt">Env</span> var val <span class="ot">-&gt;</span> val</span></code></pre></div>
<p>Then, the assignment operator can be written as</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.=) ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>(x <span class="op">.=</span> e) env <span class="ot">=</span> Map.insert x (e env) env</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">2</span> <span class="op">.=</span></span></code></pre></div>
<p>This allows us to create an <code>Effect</code>, which is a function, without needing to use an explicit lambda expression that calls <code>Map.insert</code>. Now, we can define the <code>modify_stmt</code> statement a bit more nicely:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">X</span> <span class="op">.=</span> (\env <span class="ot">-&gt;</span> env <span class="op">Map.!</span> <span class="dt">Y</span> <span class="op">*</span> <span class="dv">4</span>))</span></code></pre></div>
<p>This is better. However, the <code>Expr</code> we are binding <code>X</code> to is still defined in terms of a lambda expression and an explicit <code>Map.!</code> operator. We can do a bit better still by defining some more functions to build <code>Expr</code>s more cleanly.</p>
<p>If <code>x :: var</code> is a variable, we can create a corresponding expression for <code>x</code>. In our representation, the <em>expression</em> for <code>x</code> will be a function that simply looks up <code>x</code> in the environment and returns its value.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">var ::</span> <span class="dt">Ord</span> var <span class="ot">=&gt;</span> var <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>var x env <span class="ot">=</span> env <span class="op">Map.!</span> x</span></code></pre></div>
<p>If <code>c :: val</code> is a constant value, we can create a corresponding expression for <code>c</code>. In our representation, the <em>expression</em> for <code>c</code> will be a function that ignores the current environment and blindly returns the value <code>c</code>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">val ::</span> val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>val c _ <span class="ot">=</span> c</span></code></pre></div>
<p>If <code>val</code> is a numeric type, we can lift the usual numeric operators to expressions. This can actually be accomplished by providing an orphan <code>Num</code> instance for functions:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Num</span> b <span class="ot">=&gt;</span> <span class="dt">Num</span> (a <span class="ot">-&gt;</span> b) <span class="kw">where</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  (<span class="op">+</span>) <span class="ot">=</span> liftA2 (<span class="op">+</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>  (<span class="op">*</span>) <span class="ot">=</span> liftA2 (<span class="op">*</span>)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>  (<span class="op">-</span>) <span class="ot">=</span> liftA2 (<span class="op">-</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">abs</span> <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">abs</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">signum</span> <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">signum</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">fromInteger</span> <span class="ot">=</span> <span class="fu">const</span> <span class="op">.</span> <span class="fu">fromInteger</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">negate</span> <span class="ot">=</span> <span class="fu">fmap</span> <span class="fu">negate</span></span></code></pre></div>
<p>Since an <code>Expr var val</code> is just a function <code>Env var val -&gt; val</code>, this means that if <code>val</code> has a <code>Num</code> instance, we have a corresponding instance for <code>Expr var val</code> that behaves in the way we’d expect.</p>
<p>Now, we can rewrite our <code>int x = y * 4;</code> statement in a much nicer way:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">modify_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>modify_stmt <span class="ot">=</span> <span class="dt">Modify</span> (<span class="dt">X</span> <span class="op">.=</span> var <span class="dt">Y</span> <span class="op">*</span> <span class="dv">4</span>)</span></code></pre></div>
<p>If we have <em>two</em> effects that we’d like to perform, one after another, we can combine them with the following operator:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;:) ::</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val <span class="ot">-&gt;</span> <span class="dt">Effect</span> var val</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(a <span class="op">&gt;:</span> b) env <span class="ot">=</span> b (a env)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">1</span> <span class="op">&gt;:</span></span></code></pre></div>
<p>If <code>a</code> and <code>b</code> are effects, <code>a &gt;: b</code> is the effect which results from first performing <code>a</code>, then performing <code>b</code>. This is useful when we wish to update two variables atomically, i.e. perform both updates in a single step of the program.</p>
<h2 id="the-ifgoto-statement">The <code>IfGoto</code> statement</h2>
<p>In this section, we’ll define a few helper functions to help us write <code>IfGoto</code> statements in a readable way. <code>IfGoto</code> takes an <em>environment predicate</em> and a line number as arguments:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">IfGoto</span><span class="ot"> ::</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val) <span class="ot">-&gt;</span> <span class="dt">LineNumber</span> <span class="ot">-&gt;</span> <span class="dt">Stmt</span> var val</span></code></pre></div>
<p>Recall from the previous post that a predicate is just a single-argument function that returns a <code>Bool</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Predicate</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>Therefore, a <code>Predicate (Env var val)</code> is a function <code>Env var val -&gt; Bool</code>. If this function evaluates to <code>True</code> in the current environment, the line number should change to the value specified by the second argument of <code>IfGoto</code>, the <code>LineNumber</code>.</p>
<p>In C, we might see a conditional <code>goto</code> statement like this:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (x == <span class="dv">1</span> + y) <span class="cf">goto</span> label;</span></code></pre></div>
<p>Ideally the programmer doesn’t use explicit <code>goto</code>s, but in <code>MIG</code> it will be the only option for affecting control flow in our programs. Let’s assume <code>label</code> refers to a specific line number, namely line 17 of the program. Then we can write the corresponding <code>IfGoto</code> statement like so:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">if_goto_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>if_goto_stmt <span class="ot">=</span> <span class="dt">IfGoto</span> (\env <span class="ot">-&gt;</span> env <span class="op">Map.!</span> <span class="dt">X</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">+</span> env <span class="op">Map.!</span> <span class="dt">Y</span>) <span class="dv">17</span></span></code></pre></div>
<p>The function we passed to <code>IfGoto</code> took the current environment, looked up the values of <code>X</code> and <code>Y</code>, and tested whether the value of <code>X</code> was equal to <code>1</code> plus the value of <code>Y</code>. As with <code>Modify</code>, we’ll write some helper functions to create these environment predicates in a way that more closely resembles the original <code>C</code> code. The first such function will be the equality operator, which evaluates two expressions and determines if the results are equal:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.==) ::</span> <span class="dt">Eq</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.==</span> e2) env <span class="ot">=</span> e1 env <span class="op">==</span> e2 env</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.==</span></span></code></pre></div>
<p>The next functions we’ll need are the inequality operators:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;=</span> e2 env</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&lt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&lt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&lt;</span> e2 env</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&lt;</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;=) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;=</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;=</span> e2 env</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;=</span></span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(.&gt;) ::</span> <span class="dt">Ord</span> val <span class="ot">=&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Expr</span> var val <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">Env</span> var val)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>(e1 <span class="op">.&gt;</span> e2) env <span class="ot">=</span> e1 env <span class="op">&gt;</span> e2 env</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">.&gt;</span></span></code></pre></div>
<p>Also note that we can combine predicates using the boolean operators <code>.&amp;</code>, <code>.|</code>, <code>pnot</code>, and <code>.-&gt;</code> as defined in the previous post; these enable us to “build up” larger predicates out of smaller ones.</p>
<p>Now, we can implement the C statement <code>if (x == 1 + y) goto label;</code> in a much nicer way:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">if_goto_stmt ::</span> <span class="dt">Stmt</span> <span class="dt">XY</span> <span class="dt">Int</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>if_goto_stmt <span class="ot">=</span> <span class="dt">IfGoto</span> (var <span class="dt">X</span> <span class="op">.==</span> <span class="dv">1</span> <span class="op">+</span> var <span class="dt">Y</span>) <span class="dv">17</span></span></code></pre></div>
<h2 id="implementing-factorial">Implementing factorial</h2>
<p>To give you a simple example of how to program in <code>MIG</code>, let’s implement factorial. We won’t do any model checking of this program; this is merely to give you (the reader) a concrete sense of how programs can be written in it.</p>
<p>We’re going to hand-translate this C function:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fact(<span class="dt">int</span> n) {</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">int</span> i = <span class="dv">2</span>, res = <span class="dv">1</span>;</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> (i &lt;= n) {</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    res *= i;</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    i += <span class="dv">1</span>;</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> res;</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
<p>into a <code>MIG</code> program. The program has three variables:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FactVar</span> <span class="ot">=</span> <span class="dt">N</span> <span class="op">|</span> <span class="dt">I</span> <span class="op">|</span> <span class="dt">Res</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Now we’re ready to write the <code>fact</code> program (line numbers are listed in comments to the left of each statement):</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">fact ::</span> <span class="dt">Prog</span> <span class="dt">FactVar</span> <span class="dt">Int</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>fact <span class="ot">=</span> Vec.fromList</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> <span class="dv">1</span> <span class="op">&gt;:</span> <span class="dt">I</span> <span class="op">.=</span> <span class="dv">2</span>)</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">IfGoto</span> (pnot (var <span class="dt">I</span> <span class="op">.&lt;=</span> var <span class="dt">N</span>)) <span class="dv">5</span></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">Res</span> <span class="op">.=</span> var <span class="dt">Res</span> <span class="op">*</span> var <span class="dt">I</span>)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> ,   <span class="dt">Modify</span> (<span class="dt">I</span> <span class="op">.=</span> var <span class="dt">I</span> <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> ,   goto <span class="dv">1</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">5</span> <span class="co">-- halt</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<p>We don’t have a separate <code>Halt</code> statement, so we model that with a <code>goto</code> statement that points to itself, infinitely looping.</p>
<h1 id="parallel-programs">Parallel programs</h1>
<p>In this section, we will examine the problem of model checking multiple programs running in parallel, which all have access to the same global variable environment. We will use <code>MIG</code> to express each individual program, and then we will define a function to convert a parallel program into a transition system.</p>
<p>A <em>parallel program</em> is just a <code>Vector</code> of sequential programs with a shared environment:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParProg</span> var val <span class="ot">=</span> <span class="dt">Vector</span> (<span class="dt">Prog</span> var val)</span></code></pre></div>
<p>We will use the term <em>process</em> to denote a sequential program that is part of a larger parallel program. The <em>process id</em> of a particular process is just its index within this vector.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ProcId</span> <span class="ot">=</span> <span class="dt">Int</span></span></code></pre></div>
<p>To “run” a parallel program, we first start each process at line 0. Then, we arbitrarily pick which process will execute next, and we execute that process’s current statement, updating the global variable environment and/or that process’s current line number. This type of parallel execution model is called <em>interleaving</em>, because each process advances independently of the other, and the processes can advance in any order.</p>
<h2 id="example-petersons-mutual-exclusion-algorithm">Example: Peterson’s mutual exclusion algorithm</h2>
<p>Consider two processes, P0 and P1, which are running corresponding programs. Suppose that each program has a <em>critical section</em>, and if P0 and P1 are ever both in their critical sections, bad things can happen. The property that both processes cannot execute their critical sections simultaneously is called <em>mutual exclusion</em>.</p>
<p>Peterson’s algorithm is an elegant way to ensure mutual exclusion. It uses three variables: <code>Turn</code>, <code>Wait0</code>, and <code>Wait1</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">PeteVar</span> <span class="ot">=</span> <span class="dt">Turn</span> <span class="op">|</span> <span class="dt">Wait0</span> <span class="op">|</span> <span class="dt">Wait1</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p>Intuitively, the meaning of each variable is as follows:</p>
<ul>
<li><code>Turn</code> is <code>False</code> it if is <code>P0</code>’s turn to enter its critical section, and <code>True</code> if it is <code>P1</code>’s turn.</li>
<li><code>Wait0</code> is <code>True</code> if <code>P0</code> wishes to enter its critical section or is currently in its critical section, and <code>False</code> otherwise.</li>
<li><code>Wait1</code> is <code>True</code> if <code>P1</code> wishes to enter its critical section or is currently in its critical section, and <code>False</code> otherwise.</li>
</ul>
<p>We implement Peterson’s algorithm in <code>MIG</code> as a parallel program with two processes. Each process is in an infinite loop, continually attempting to enter its own critical section. When a process wants to enter its critical section, it first sets its own <code>Wait</code> variable to <code>True</code>, and then it (somewhat counterintuitively) signals that it is the <em>other</em> process’s turn. Then, before it enters its own critical section, it busy-waits until either the other process is not waiting, or its own turn has arrived. Finally, when the critical section is complete, the process sets its <code>Wait</code> variable to <code>False</code>, indicating it has exited its critical section, and the other process is free to enter theirs. The process then loops back to the beginning, and again attempts to enter its critical section.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pete_0 ::</span> <span class="dt">Prog</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>pete_0 <span class="ot">=</span> Vec.fromList</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Wait0</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">Modify</span> (<span class="dt">Turn</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> , <span class="dt">IfGoto</span> (var <span class="dt">Turn</span> <span class="op">.&amp;</span> var <span class="dt">Wait1</span>) <span class="dv">2</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> , noop <span class="co">-- CRITICAL SECTION</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait0</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">0</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pete_1 ::</span> <span class="dt">Prog</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>pete_1 <span class="ot">=</span> Vec.fromList</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Wait1</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">Modify</span> (<span class="dt">Turn</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> , <span class="dt">IfGoto</span> (pnot (var <span class="dt">Turn</span>) <span class="op">.&amp;</span> var <span class="dt">Wait0</span>) <span class="dv">2</span></span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> , noop <span class="co">-- CRITICAL SECTION</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait1</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">0</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ot">pete ::</span> <span class="dt">ParProg</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>pete <span class="ot">=</span> Vec.fromList [ pete_0, pete_1 ]</span></code></pre></div>
<p>It is possible to reason through why this solution works, and even to write a formal proof that both processes cannot be at line 3 simultaneously. However, by converting this parallel program to a transition system, we can automatically check that Peterson’s algorithm ensures mutual exclusion. In the next section, we discuss how to perform this conversion, and then apply it to this algorithm.</p>
<h2 id="from-parallel-programs-to-transition-systems">From parallel programs to transition systems</h2>
<p>In order to model check a parallel program, we first convert such a program into a transition system. The basic idea for the conversion will be that a state in the transition system will be a pair <code>(Vector LineNumber, Env var val)</code>, consisting of the current line number of each process, and the current values of the global variable environment.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParProgState</span> var val <span class="ot">=</span> (<span class="dt">Vector</span> <span class="dt">LineNumber</span>, <span class="dt">Env</span> var val)</span></code></pre></div>
<p>Every state <code>(lineNums, env)</code> will have exactly <code>Vec.length lineNums</code> outgoing transitions, each corresponding to executing the current line of one of the running processes.</p>
<p>What should the set of atomic propositional variables be for the transition system of a program? Instead of choosing this for all programs, we defer this choice to the caller. The caller will provide a list of atomic propositional variables, along with a function which maps each variable to a <em>state predicate</em>, i.e. a <code>Predicate (ParProgState var val)</code>. Then, the label of each state will be the set of variables whose corresponding predicate is true about the current state.</p>
<p>The <code>action</code> type will just be a <code>(ProcId, LineNumber)</code> pair, corresponding to “performing the statement at the given line of the given process.” As in the previous post, the <code>action</code> is just a name for each transition, and does not have any semantic content whatsoever.</p>
<p>Let’s define <code>parProgToTS</code>, which converts a parallel program to a transition system:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parProgToTS ::</span> [<span class="dt">Env</span> var val]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> [ap]</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> (ap <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">ParProgState</span> var val))</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">ParProg</span> var val</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">TransitionSystem</span> (<span class="dt">ParProgState</span> var val) (<span class="dt">ProcId</span>, <span class="dt">LineNumber</span>) ap</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>parProgToTS initialEnvs aps apToPred parProg <span class="ot">=</span> <span class="dt">TransitionSystem</span></span></code></pre></div>
<p>The <code>initialEnvs</code> argument is a list of all initial environments we are considering. <code>aps</code> is the complete list of atomic propositional variables, and <code>apToPred</code> maps each atomic propositional variable to its corresponding state predicate. For each initial environment provided by the caller, there is a corresponding initial state in the transition system with every process starting at line 0:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>  { tsInitialStates <span class="ot">=</span> [(Vec.replicate (Vec.length parProg) <span class="dv">0</span>, env) <span class="op">|</span> env <span class="ot">&lt;-</span> initialEnvs]</span></code></pre></div>
<p>States are labeled by the atomic propositional variables whose corresponding predicates they satisfy:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>  , tsLabel <span class="ot">=</span> \s <span class="ot">-&gt;</span> [ p <span class="op">|</span> p <span class="ot">&lt;-</span> aps, s <span class="op">|=</span> apToPred p ]</span></code></pre></div>
<p>Each state has one outgoing transition for every process in the input program, corresponding to executing the current line of that particular process.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>  , tsTransitions <span class="ot">=</span> \(lineNums, env) <span class="ot">-&gt;</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>      [ t env lineNums procId <span class="op">|</span> procId <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>Vec.length parProg<span class="op">-</span><span class="dv">1</span>] ]</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> t env lineNums procId <span class="ot">=</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> lineNum <span class="ot">=</span> lineNums <span class="op">Vec.!</span> procId</span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>              process <span class="ot">=</span> parProg <span class="op">Vec.!</span> procId</span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>              action <span class="ot">=</span> (procId, lineNum)</span>
<span id="cb45-8"><a href="#cb45-8" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> <span class="kw">case</span> process <span class="op">Vec.!</span> lineNum <span class="kw">of</span></span>
<span id="cb45-9"><a href="#cb45-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Modify</span> effect <span class="ot">-&gt;</span></span>
<span id="cb45-10"><a href="#cb45-10" aria-hidden="true" tabindex="-1"></a>              (action, (lineNums <span class="op">Vec.//</span> [(procId, lineNum<span class="op">+</span><span class="dv">1</span>)], effect env))</span>
<span id="cb45-11"><a href="#cb45-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">IfGoto</span> p lineNum&#39;</span>
<span id="cb45-12"><a href="#cb45-12" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> env <span class="op">|=</span> p  <span class="ot">-&gt;</span> (action, (lineNums <span class="op">Vec.//</span> [(procId, lineNum&#39; )], env))</span>
<span id="cb45-13"><a href="#cb45-13" aria-hidden="true" tabindex="-1"></a>              <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> (action, (lineNums <span class="op">Vec.//</span> [(procId, lineNum<span class="op">+</span><span class="dv">1</span>)], env))</span></code></pre></div>
<h2 id="checking-petersons-algorithm">Checking Peterson’s algorithm</h2>
<p>The correctness property for Peterson’s algorithm is simple: both processes should never be in their critical sections simultaneously. To ensure that this is true, we use the following type for the atomic propositional variables:</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ProcAtLine</span> <span class="ot">=</span> <span class="dt">ProcAtLine</span> <span class="dt">ProcId</span> <span class="dt">LineNumber</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)</span></code></pre></div>
<p><code>ProcAtLine procId lineNum</code> represents the predicate that “process <code>procId</code> is currently at line <code>lineNum</code>.” This is codified by the following function:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">procAtLinePred ::</span> <span class="dt">ProcAtLine</span> <span class="ot">-&gt;</span> <span class="dt">Predicate</span> (<span class="dt">ParProgState</span> var val)</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>procAtLinePred (<span class="dt">ProcAtLine</span> procId lineNum) <span class="ot">=</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>  \(lineNums, _) <span class="ot">-&gt;</span> lineNums <span class="op">Vec.!</span> procId <span class="op">==</span> lineNum</span></code></pre></div>
<p>In order to call <code>peteTS</code>, we also need to collect all of the atomic propositional variables. These will be <code>ProcAtLine procId lineNum</code> for every valid <code>(ProcId, LineNumber)</code> pair. We can collect all such pairs for an arbitrary <code>ParProg</code> with the following function:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">enumProcAtLine ::</span> <span class="dt">ParProg</span> var val <span class="ot">-&gt;</span> [<span class="dt">ProcAtLine</span>]</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>enumProcAtLine parProg <span class="ot">=</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  [ <span class="dt">ProcAtLine</span> procId lineNum <span class="op">|</span> procId  <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>Vec.length parProg <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>                              , lineNum <span class="ot">&lt;-</span> [<span class="dv">0</span><span class="op">..</span>Vec.length (parProg <span class="op">Vec.!</span> procId) <span class="op">-</span> <span class="dv">1</span>] ]</span></code></pre></div>
<p>Now, we can define the transition system for the <code>pete</code> program as follows:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="ot">peteTS ::</span> <span class="dt">TransitionSystem</span> (<span class="dt">ParProgState</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span>) (<span class="dt">ProcId</span>, <span class="dt">LineNumber</span>) <span class="dt">ProcAtLine</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>peteTS <span class="ot">=</span> parProgToTS [initialEnv] (enumProcAtLine pete) procAtLinePred pete</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> initialEnv <span class="ot">=</span> Map.fromList [ (<span class="dt">Turn</span>, <span class="dt">False</span>), (<span class="dt">Wait0</span>, <span class="dt">False</span>), (<span class="dt">Wait1</span>, <span class="dt">False</span>) ]</span></code></pre></div>
<p>Note that there is only one initial environment; all three variables are initially <code>False</code>.</p>
<p>The critical section occurs at line 3 in both processes, so the property that both processes are not simultaneously in their critical sections is stated as follows:</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>pnot (atom (<span class="dt">ProcAtLine</span> <span class="dv">0</span> <span class="dv">3</span>) <span class="op">.&amp;</span> atom (<span class="dt">ProcAtLine</span> <span class="dv">1</span> <span class="dv">3</span>))</span></code></pre></div>
<p>Let’s check that this property is an invariant for <code>peteTS</code> transition system:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom (<span class="dt">ProcAtLine</span> <span class="dv">0</span> <span class="dv">3</span>) <span class="op">.&amp;</span> atom (<span class="dt">ProcAtLine</span> <span class="dv">1</span> <span class="dv">3</span>))) peteTS</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Nothing</span></span></code></pre></div>
<p>Glancing back at each process in Peterson’s algorithm, we see that the assignment to the <code>Wait</code> variable occurs <em>before</em> the assignment to <code>Turn</code>. What happens if we swap the two? Will our property still hold?</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad_pete_0 ::</span> <span class="dt">Prog</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>bad_pete_0 <span class="ot">=</span> Vec.fromList</span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Turn</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait0</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> , <span class="dt">IfGoto</span> (var <span class="dt">Turn</span> <span class="op">.&amp;</span> var <span class="dt">Wait1</span>) <span class="dv">2</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> , noop <span class="co">-- CRITICAL SECTION</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait0</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">0</span></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad_pete_1 ::</span> <span class="dt">Prog</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>bad_pete_1 <span class="ot">=</span> Vec.fromList</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 0 -}</span> [ <span class="dt">Modify</span> (<span class="dt">Turn</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 1 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait1</span> <span class="op">.=</span> val <span class="dt">True</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 2 -}</span> , <span class="dt">IfGoto</span> (pnot (var <span class="dt">Turn</span>) <span class="op">.&amp;</span> var <span class="dt">Wait0</span>) <span class="dv">2</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 3 -}</span> , noop <span class="co">-- CRITICAL SECTION</span></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 4 -}</span> , <span class="dt">Modify</span> (<span class="dt">Wait1</span> <span class="op">.=</span> val <span class="dt">False</span>)</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">{- 5 -}</span> , goto <span class="dv">0</span></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>          ]</span></code></pre></div>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad_pete ::</span> <span class="dt">ParProg</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>bad_pete <span class="ot">=</span> Vec.fromList [ bad_pete_0, bad_pete_1 ]</span></code></pre></div>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell literate"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad_peteTS ::</span> <span class="dt">TransitionSystem</span> (<span class="dt">ParProgState</span> <span class="dt">PeteVar</span> <span class="dt">Bool</span>) (<span class="dt">ProcId</span>, <span class="dt">LineNumber</span>) <span class="dt">ProcAtLine</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>bad_peteTS <span class="ot">=</span> parProgToTS [initialEnv] (enumProcAtLine bad_pete) procAtLinePred bad_pete</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> initialEnv <span class="ot">=</span> Map.fromList [ (<span class="dt">Turn</span>, <span class="dt">False</span>), (<span class="dt">Wait0</span>, <span class="dt">False</span>), (<span class="dt">Wait1</span>, <span class="dt">False</span>) ]</span></code></pre></div>
<p>The naming of these programs probably tips you off about the outcome of our little experiment. Let’s try it:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> checkInvariant (pnot (atom (<span class="dt">ProcAtLine</span> <span class="dv">0</span> <span class="dv">3</span>) <span class="op">.&amp;</span> atom (<span class="dt">ProcAtLine</span> <span class="dv">1</span> <span class="dv">3</span>))) bad_peteTS</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> (([<span class="dv">3</span>,<span class="dv">3</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)]),<span class="dt">Path</span> {pathHead <span class="ot">=</span> ([<span class="dv">0</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">False</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)]), pathTail <span class="ot">=</span> [((<span class="dv">0</span>,<span class="dv">0</span>),([<span class="dv">1</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">1</span>),([<span class="dv">2</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">2</span>),([<span class="dv">3</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">3</span>),([<span class="dv">4</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">4</span>),([<span class="dv">5</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">5</span>),([<span class="dv">0</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">1</span>,<span class="dv">0</span>),([<span class="dv">0</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">False</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">0</span>),([<span class="dv">1</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">1</span>),([<span class="dv">2</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">0</span>,<span class="dv">2</span>),([<span class="dv">3</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])),((<span class="dv">1</span>,<span class="dv">1</span>),([<span class="dv">3</span>,<span class="dv">2</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)])),((<span class="dv">1</span>,<span class="dv">2</span>),([<span class="dv">3</span>,<span class="dv">3</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)]))]})</span></code></pre></div>
<p>Oh no! Looks like it doesn’t hold. Let’s make the counterexample a bit more readable so we can analyze what went wrong:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="dt">Just</span> (_, path) <span class="ot">=</span> checkInvariant (pnot (atom (<span class="dt">ProcAtLine</span> <span class="dv">0</span> <span class="dv">3</span>) <span class="op">.&amp;</span> atom (<span class="dt">ProcAtLine</span> <span class="dv">1</span> <span class="dv">3</span>))) bad_peteTS</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>  <span class="op">&gt;</span> <span class="fu">print</span> (pathHead path) <span class="op">&gt;&gt;</span> <span class="fu">mapM_</span> <span class="fu">print</span> (<span class="fu">snd</span> <span class="op">&lt;$&gt;</span> pathTail path)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">0</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">False</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">1</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">2</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">4</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">5</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">0</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">0</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">False</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">1</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">2</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])</span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">2</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)])</span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">3</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)])</span></code></pre></div>
<p>Here is the important bit, annotated with letters for discussion:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">0</span>,<span class="dv">0</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])  <span class="co">-- a</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">0</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">False</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)]) <span class="co">-- b</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">1</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">False</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])  <span class="co">-- c</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">2</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])   <span class="co">-- d</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">1</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">False</span>)])   <span class="co">-- e</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">2</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)])    <span class="co">-- f</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>  ([<span class="dv">3</span>,<span class="dv">3</span>],fromList [(<span class="dt">Turn</span>,<span class="dt">True</span>),(<span class="dt">Wait0</span>,<span class="dt">True</span>),(<span class="dt">Wait1</span>,<span class="dt">True</span>)])    <span class="co">-- g</span></span></code></pre></div>
<p>At a, both processes are at line 0. First, P1 sets <code>Turn</code> to <code>False</code>, indicating it is P0’s turn to enter the critical section. Then, P0 sets it to <code>True</code>, indicating it is P1’s turn. Then, at c, P0 sets <code>Wait0</code> to <code>True</code>, indicating it wishes to enter. At line d, P0 enters its critical section even though <code>Turn</code> is <code>True</code>, because <code>Wait1</code> is still <code>False</code>. Then, P1 is able to enter <em>its</em> critical section, because <code>Turn</code> is <code>True</code>.</p>
<p>We see that it <em>really matters</em> that the <code>Wait</code> variables are updated <em>before</em> the <code>Turn</code> flag is flipped! Otherwise, the algorithm simply does not work.</p>
<h1 id="whats-next">What’s next?</h1>
<p>In this post, we applied model checking to a real-world program and proved something valuable and non-trivial. Peterson’s algorithm isn’t <em>too</em> complicated, but it’s not easy to see why it’s correct at first glance. We saw that by translating it to a transition system, we could exhaustively explore the reachable state space, and found that it was impossible to violate the desired invariant. When we modified the program slightly, we discovered that the invariant failed. Furthermore, the model checking approach discovered a counterexample that helped us to understand <em>why</em> it failed.</p>
<p>So far in this series, the only properties we have explored and checked are <em>invariants</em>. However, there are some properties that cannot be expressed as invariants; for instance, the property that a traffic light will be green infinitely often, or that a yellow light always precedes a red light. In the next post, we will explore a larger class of properties called <em>regular safety properties</em>. We will show how to use <em>nondeterministic finite automata</em> to express such properties, and how to check whether these properties hold.</p>
</body>
</html>
